/* controllers
   En este m√≥dulo se encuentran los controllers(controladores).
   En el patr√≥n de dise√±o MVC (Modelo - Vista - Controlador),
   el controlador es el que:
   Recibe las solicitudes (requests) del usuario.
   Procesa los datos (a veces usando modelos).
   Env√≠a las respuestas (responses) al cliente.
   ¬øQu√© hace exactamente un controlador?
   Un controlador en Node.js/Express es una funci√≥n (o grupo de funciones)
   que maneja la l√≥gica detr√°s de cada acci√≥n
   que se puede hacer con un recurso, como:
   | Acci√≥n     | Ruta            | M√©todo HTTP | Qu√© hace el controlador    |
   | ---------- | --------------- | ----------- | -------------------------- |
   | Crear      | `/usuarios`     | `POST`      | Crear un nuevo usuario     |
   | Leer       | `/usuarios`     | `GET`       | Obtener todos los usuarios |
   | Actualizar | `/usuarios/:id` | `PUT`       | Actualizar usuario por ID  |
   | Eliminar   | `/usuarios/:id` | `DELETE`    | Eliminar usuario por ID    |
   Estas funciones est√°n en archivos como usuarioController.js,
   y se agrupan en la carpeta controllers por organizaci√≥n y mantenibilidad.
*/

/* Importar el modelo Usuario */
const Usuario = require('../models/usuario');

/* Exportar la funci√≥n crear usuario
   
   Esta parte:
   
   exports.crearUsuario = async (req, res) => {

   Est√° exportando una funci√≥n llamada crearUsuario desde un archivo
   (en este caso, usuarioController.js)
   para que pueda ser usada en otras partes del proyecto,
   como por ejemplo en tus rutas.

   ¬øQu√© significa exports?

   exports es un objeto especial en Node.js.
   Sirve para hacer que funciones, objetos o variables
   est√©n disponibles fuera del archivo actual.
   Es parte del sistema de m√≥dulos de Node.js.

   Sistema de m√≥dulos de Node.js

   ¬øQu√© es un m√≥dulo?

   En Node.js, un m√≥dulo es cualquier archivo JavaScript
   que contiene c√≥digo que puede exportar (dar acceso a otros archivos)
   o importar (traer desde otros archivos) funcionalidades.

   ¬øPara qu√© sirve?

   El sistema de m√≥dulos permite que puedas:

   Dividir tu aplicaci√≥n en archivos m√°s peque√±os y organizados.
   Reutilizar c√≥digo en diferentes partes del proyecto.
   Separar responsabilidades: controladores, modelos, rutas, etc.

   ¬øQu√© es el "sistema de m√≥dulos"?

   El sistema de m√≥dulos de Node.js es el mecanismo que permite
   importar y exportar c√≥digo entre archivos.

*/
exports.crearUsuario = async (req, res) => {
  try {
    const nuevoUsuario = new Usuario(req.body); // Crea un nuevo documento con los datos recibidos
    const resultado = await nuevoUsuario.save(); // Guarda en MongoDB
    /* Devuelve el usuario creado

       res

       Es el objeto de respuesta proporcionado por Express.
       Lo usas para responder al cliente que hizo la petici√≥n HTTP.

       .status(201)

       ¬øQu√© es un c√≥digo de estado HTTP?

       Cuando un cliente (por ejemplo, tu navegador o Thunder Client)
       hace una petici√≥n HTTP a un servidor (como tu API en Node.js),
       el servidor siempre responde con un n√∫mero especial
       llamado c√≥digo de estado.
       Ese n√∫mero indica el resultado de la operaci√≥n.
       Es parte de c√≥mo funciona el protocolo HTTP
       (el lenguaje que usan los navegadores y servidores para comunicarse).

       ¬øQu√© significa configurar el c√≥digo de estado?

       Cuando t√∫ haces esto en tu c√≥digo: res.status(201)
       Est√°s dici√©ndole a Express (y al navegador o cliente
       que recibe la respuesta):
       ‚Äú‚úÖ Todo bien. El recurso se cre√≥ correctamente. C√≥digo 201.‚Äù
       Es decir, est√°s especificando manualmente qu√© n√∫mero de estado
       (como 200, 201, 400...) devolver√° el servidor
       para que el cliente entienda qu√© pas√≥ con su petici√≥n.
       
       Ejemplos de c√≥digos de estado comunes

       | C√≥digo | Significado           | Cu√°ndo se usa                                 |
       | ------ | --------------------- | --------------------------------------------- |
       | 200    | OK                    | Todo sali√≥ bien (respuesta normal)            |
       | 201    | Created               | Algo nuevo se cre√≥ (por ejemplo, un usuario)  |
       | 400    | Bad Request           | El cliente envi√≥ datos inv√°lidos              |
       | 401    | Unauthorized          | No est√° autorizado (falta login, por ejemplo) |
       | 404    | Not Found             | No se encontr√≥ lo solicitado                  |
       | 500    | Internal Server Error | El servidor fall√≥ por un error interno        |

       .json(resultado)

       Env√≠a una respuesta en formato JSON al cliente.
       resultado contiene el nuevo usuario que fue guardado en la base de datos.

    */
    res.status(201).json(resultado);
    // Manejo de errores de validaci√≥n
  } catch (err) {
    // #region Comprueba si el error fue causado por una validaci√≥n de Mongoose. 
               /* err.name devuelve el tipo de error. 
                  Estructura t√≠pica de err (cuando es ValidationError de Mongoose):

                  {
                    name: 'ValidationError',    // Tipo de error
                    message: 'Usuario validation failed: nombre: El nombre es obligatorio, edad: La edad m√≠nima es 1',
                    errors: {
                      nombre: {
                        message: 'El nombre es obligatorio',
                        name: 'ValidatorError',
                        kind: 'required',
                        path: 'nombre',
                        value: ''
                      },
                      edad: {
                        message: 'La edad m√≠nima es 1',
                        name: 'ValidatorError',
                        kind: 'min',
                        path: 'edad',
                        value: 0
                      }
                    },
                    _message: 'Usuario validation failed'
                 }

                  Cuando se produce un error por no cumplir las reglas del modelo
                  (como edad m√≠nima, campo requerido, etc.),
                  Mongoose lo clasifica como "ValidationError". 
               */        
    // #endregion    
    if (err.name === 'ValidationError') {
      /* Se extrae los mensajes de error seg√∫n los errores de validaci√≥n

         err.errors tendr√° esta forma:
         {
            nombre: {
              message: "El nombre debe tener al menos 3 caracteres",
              name: "ValidatorError",
              kind: "minlength",
              path: "nombre",
              value: ""
            },
            edad: {
              message: "La edad m√≠nima es 1",
              name: "ValidatorError",
              kind: "min",
              path: "edad",
              value: 0
            }
          }
          
          Cada propiedad (como nombre, edad) es un subobjeto
          con informaci√≥n sobre qu√© sali√≥ mal:

          message: El mensaje que escribiste en el esquema
          ('El nombre debe tener al menos 3 caracteres').
          name: Tipo de error (ValidatorError).
          kind: Qu√© tipo de validaci√≥n fall√≥ (minlength, min, etc.).
          path: El nombre del campo (nombre, edad).
          value: El valor que caus√≥ el error ("", 0, etc.).

          Paso a paso

          1. Object.values(err.errors)

          Esto convierte el objeto en un array
          con los valores (sin las claves). El resultado ser√≠a:

          [
            {
              message: 'El nombre debe tener al menos 3 caracteres',
              name: 'ValidatorError',
              kind: 'minlength',
              path: 'nombre',
              value: 'Jo'
            },
            {
              message: 'La edad m√≠nima es 1',
              name: 'ValidatorError',
              kind: 'min',
              path: 'edad',
              value: 0
            }
          ]

          2. .map(e => e.message)

             Esto recorre cada uno de los elementos del array anterior (e)
             y extrae la propiedad message de cada uno. El resultado ser√≠a:

             [
                'El nombre debe tener al menos 3 caracteres',
                'La edad m√≠nima es 1'
              ]

          Supuesto: Error solo en nombre

          üö´ Petici√≥n con error:

          Sup√≥n que se intenta enviar un usuario con estos datos:

          {
            "nombre": "Jo",   // Solo 2 letras (m√≠nimo requerido es 3)
            "edad": 25        // Edad correcta
          }
          
          ‚ùå Mongoose detecta un error solo en nombre

          Entonces, el objeto err.errors generado por Mongoose ser√≠a:

          {
            nombre: {
              message: 'El nombre debe tener al menos 3 caracteres',
              name: 'ValidatorError',
              kind: 'minlength',
              path: 'nombre',
              value: 'Jo'
            }
          }
          
          Solo aparece el campo nombre porque la edad s√≠ pas√≥ la validaci√≥n.

      */
      const mensajes = Object.values(err.errors).map(e => e.message);
      /* Respuesta al cliente con estado 400 y el mensaje de error
         
         Estado 400:
         El cliente envi√≥ datos inv√°lidos
         
         .json(...)

         Est√°s enviando la respuesta en formato JSON
         (muy com√∫n en APIs modernas).
         Este m√©todo:
         Convierte el objeto que le pases a JSON autom√°ticamente.
         Lo env√≠a al cliente como respuesta HTTP.

         { error: mensajes.join(', ') }

         Este es el objeto que se convierte en JSON.

          mensajes:

          ['El nombre debe tener al menos 3 caracteres', 'La edad m√≠nima es 1']

          ¬øQu√© hace .join(', ')?

          Convierte ese array en un solo string separado por comas:

          "El nombre debe tener al menos 3 caracteres, La edad m√≠nima es 1"

          Resultado final:

          Entonces { error: ... } se convierte en:

          {
            "error": "El nombre debe tener al menos 3 caracteres, La edad m√≠nima es 1"
          }

          Esto es lo que ve el cliente (Thunder Client, el navegador,
          o el frontend React, por ejemplo).

      */
      res.status(400).json({ error: mensajes.join(', ') });
    } else {
      /* Respuesta al cliente con estado 500 y mensaje de error
         
         Estado 500: El servidor fall√≥ por un error interno

         .json({ error: 'Error del servidor' })

         Se env√≠a al cliente en formato JSON, lo siguiente:

         { "error": 'Error del servidor' }

      */
      res.status(500).json({ error: 'Error del servidor' });
    }
  }
};

/* Exportar la funci√≥n obtener usuarios */
exports.obtenerUsuarios = async (req, res) => {
  try {
    const usuarios = await Usuario.find(); // Consulta todos los usuarios
    res.json(usuarios); // Devuelve como JSON
    // Manejo de errores
  } catch (err) {
    // Se env√≠a estado 500 y el mensaje de error
    res.status(500).json({ error: err.message });
  }
};

/* Exportar la funci√≥n actualizarUsuario */
exports.actualizarUsuario = async (req, res) => {
  try {
    const usuarioActualizado = await Usuario.findByIdAndUpdate(
      req.params.id, // ID del usuario
      req.body,      // Nuevos datos (nombre, edad)
      { new: true }  // Devuelve el documento actualizado
    ); // Actualiza usuario
    /* Se le env√≠a al cliente los datos actualizados del usuario
       Se convierte los datos actualizados del usuario a formato JSON
       y se le env√≠a al cliente 
    */
    res.json(usuarioActualizado);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

/* Exportar la funci√≥n eliminarUsuario */
exports.eliminarUsuario = async (req, res) => {
  try {
    await Usuario.findByIdAndDelete(req.params.id); // Borra el documento
    res.json({ mensaje: 'Usuario eliminado correctamente' });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};
